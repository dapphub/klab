#!/usr/bin/env node

const fs            = require("fs");
const path          = require("path");
const marked        = require("marked");
const {docopt}      = require("docopt");
const clc           = require("cli-color");
const _             = require("lodash");
const Config        = require("../lib/config.js");
const kjson         = require("../lib/kjson.js");
const {
  makePrelude,
  makeRules,
  makeRunScript,
  parseAct,
  buildAct
}                   = require("../lib/build.js");
const {
  testPath,
  revert,
  ensureDirs
}                   = require("../lib/util.js");

const usage = `
Usage:
  klab build [options]

Options:
  --spec=<spec>
  --filter=<filter>
  --trust
`
const cmd = docopt(usage, {
  argv: ["build"].concat(process.argv.slice(2))
});

const warn          = str => console.log(clc.xterm(214)(str))
const config_json   = JSON.parse(fs.readFileSync("./config.json"));
const config        = Config(config_json);
const config_path   = cmd["--spec"] || config.src.specification;
const filter_subject= cmd["--filter"] || null;
const raw_md_config = fs.readFileSync(config_path).toString()
const raw_config    = marked.lexer(raw_md_config)
const acts_str      = raw_config
                      .filter(e => e.type === "code")
                      .map(e => e.text)
                      .join("\n\n")
ensureDirs(["out", "out/specs", "out/acts"]);
fs.writeFileSync(path.join("out/", path.basename(config_path, ".md") + ".acts"), acts_str);

config.trusted = cmd["--trust"];

const acts_str_arr  = acts_str
  .split(/\nbehaviour\s/)
  .map((s, i) => (i == 0 ? s : "behaviour " + s))



// remove comments
// console.log(acts_str.replace(/\/\/[^\n]*\n/g, ""));


// searches and adds abi variables with "ABI_" prefix

let act_objects = acts_str_arr
  .map(parseAct)



let acts = act_objects
  .map(buildAct(config))
  .reduce((a, cs) => a.concat(cs), [])

const out = acts
  //For some reason, the above code generates a list of lists.
  //Below applies the multiplication of the monad
  .reduce((a, act) => ({...a, [act.name]: {v2n: act.v2n, act: act.act}}), {})


//Add the imported rules from the calls field
acts.forEach(rule => {
    let imports = [];
    rule.imports.map(name => {
        console.log('Importing ' + name + ' to ' + rule.name + ' spec' + (config.trusted ? ' as a trusted lemma' : ''))
        let importing = acts.filter(rul => rul.name == name || rul.name == name + "_fail")
            .map(rule => rule.spec + (Config.trusted ? '\n[trusted]\n' : '\n'))
        if (importing.length == 0) {
            warn(`Act "${name}" not found!`);
        }
        imports.push(importing)
    })
    rule.imports = imports;
})

acts.forEach(rule => {
    let _rules = [rule.spec].concat(rule.imports)
    let module = kjson.renderModule(_rules, rule.name)
    fs.writeFileSync("out/specs/proof-" + rule.name + ".k", module)
})

fs.writeFileSync("out/out.json", JSON.stringify(out, false, 2))
makeRunScript();
// RULES
makeRules(config);
// prelude
makePrelude(config);
