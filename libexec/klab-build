#!/usr/bin/env node

const fs            = require("fs");
const path          = require("path");
const marked        = require("marked");
const {docopt}      = require("docopt");
const clc           = require("cli-color");
const _             = require("lodash");
const kjson         = require("../lib/kjson.js");
const Config        = require("../lib/config.js");
const {
  makePrelude,
  makeRules,
  makeRunScript,
  getActs,
  parseAct,
  buildAct
}                   = require("../lib/build.js");
const {
  read,
  testPath,
  revert,
  ensureDirs,
  warn
}                   = require("../lib/util.js");

const KLAB_OUT = process.env.KLAB_OUT || "out";

const usage = `
Usage:
  klab build [options]

Options:
  --spec=<spec>
  --filter=<filter>
  --trust
`
const cmd = docopt(usage, {
  argv: ["build"].concat(process.argv.slice(2))
});

const config_json   = JSON.parse(fs.readFileSync("./config.json"));
const config        = Config(config_json);
const config_path   = cmd["--spec"] || config.src.specification;
const filter_subject= cmd["--filter"] || null;

const raw_md_config = read(config_path)

ensureDirs([
  KLAB_OUT,
  path.join(KLAB_OUT, "specs"),
  path.join(KLAB_OUT, "acts"),
  path.join(KLAB_OUT, "gas")
]);

config.trusted = cmd["--trust"];

const acts_str_arr = getActs(raw_md_config);


// searches and adds abi variables with "ABI_" prefix

let act_collection = acts_str_arr
  .map(parseAct)

// * build tests cases
// * enrich with gas conditions
// act2name
const __a2n = act => act.subject + "_" + act.name;
const __hasGas = name => testPath(path.join(KLAB_OUT, "gas", name + ".kast"));
const __getGas = name => read(path.join(KLAB_OUT, "gas", name + ".kast"));
const proof_collection = act_collection
  // split into pass and fail cases
  .map(act => [{
    act: {...act},
    name: __a2n(act) + "_pass",
    pass: true,
    oog: false
  }].concat("iff" in act ? [{
    act: {...act},
    pass: false,
    oog: false,
    name: __a2n(act) + "_fail"
  }] : [] ))
  .reduce((a, cs) => a.concat(cs), [])
  // enrich with gas statements
  .map(pf => {
    // TODO - default
    var gas = "3000000";
    if(__hasGas(pf.name)) {
      pf.act.gas = __getGas(pf.name);
      return [{...pf}, {...pf, oog: true, name: pf.name + "_oog"}]
    } else {
      pf.act.gas = gas;
      return [{...pf}]
    }
  })
  .reduce((a, cs) => a.concat(cs), [])

let act_proofs = proof_collection
  .map(buildAct(config))

// let acts = act_collection
//   .map(buildAct(config))
//   .reduce((a, cs) => a.concat(cs), [])

const out = act_proofs
  //For some reason, the above code generates a list of lists.
  //Below applies the multiplication of the monad
  .reduce((a, act_proof) => ({
    ...a,
    [act_proof.name]: {
      v2n: act_proof.v2n,
      act: act_proof.act
    }
  }), {})


//Add the imported rules from the calls field
act_proofs.forEach(rule => {
    let imports = [];
    rule.imports.map(name => {
        console.log('Importing ' + name + ' to ' + rule.name + ' spec' + (config.trusted ? ' as a trusted lemma' : ''))
        let importing = act_proofs.filter(rul => rul.name == name || rul.name == name + "_fail")
            .map(rule => rule.spec + (config.trusted ? '\n[trusted]\n' : '\n'))
        if (importing.length == 0) {
            warn(`Act "${name}" not found!`);
        }
        imports.push(importing)
    })
    rule.imports = imports;
})

act_proofs.forEach(rule => {
  let _rules      = [rule.spec].concat(rule.imports)
  let module      = kjson.renderModule(_rules, rule.name)
  let module_path = path.join(KLAB_OUT, "specs", `proof-${rule.name}.k`)

  let old_module  = "";
  if(testPath(module_path)) old_module = read(module_path);
  if(old_module != module) {
    console.log("write to " + module_path);
    fs.writeFileSync(module_path, module);
  }
})

fs.writeFileSync(path.join(KLAB_OUT, "out.json"), JSON.stringify(out, false, 2))
fs.writeFileSync(path.join(KLAB_OUT, "specs.manifest"), Object.keys(out).join("\n"))
makeRunScript();
// RULES
makeRules(config);
// prelude
makePrelude(config);
