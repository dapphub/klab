#!/usr/bin/env bash
set -e

red=$(tput setaf 1)
green=$(tput setaf 2)
yellow=$(tput setaf 3)
bold=$(tput bold)
reset=$(tput sgr0)
export red green yellow bold reset

if [ -z "$KLAB_OUT" ]; then
  echo "KLAB_OUT not set, defaulting to ./out/"
  KLAB_OUT=out
fi

if [ -z "$KLAB_EVMS_PATH" ]; then
  echo "KLAB_EVMS_PATH must be set and point to evm-semantics!"
  exit 1
fi

if [ "$KLAB_LAX" ]; then
  echo "KLAB_LAX flag is set to 1 -- _pass.k specs will have a weaker gas condition"
fi


export KLAB_OUT
export GAS_DIR=$KLAB_OUT/gas
export BEHAVIOUR_DIR=$KLAB_OUT/behaviour
export RUNNING_DIR=$KLAB_OUT/meta/running
export OBLIGATIONS=$KLAB_OUT/obligations.batch
export BATCH_LIMIT=8
export THREADS=${THREADS:-2}
PNAME=$(jq -r '.name' < config.json)
if [ "$PNAME" == "null" ]; then PNAME=""; fi
export PNAME

if [ -d ".git" ]; then
  build_hash=$(klab get-build-id)
  export build_hash
  if [ -n "$KLAB_REPORT_DIR" ]; then
    export KLAB_REPORT_NAME_DIR=$KLAB_REPORT_DIR/$PNAME
    export KLAB_REPORT_PROJECT_DIR=$KLAB_REPORT_DIR/$PNAME/$build_hash
    mkdir -p "$KLAB_REPORT_PROJECT_DIR"
    if [ -n "$PNAME" ]; then
      klab setup-ci-project "$PNAME"
    fi;
    if [ ! -f "$KLAB_REPORT_DIR/$PNAME"/report.json ]; then
      echo "{}" > "$KLAB_REPORT_DIR/$PNAME"/report.json
    fi;
    jq -r '.src.rules[]'     < config.json | xargs -I {} cp {} "$KLAB_REPORT_PROJECT_DIR"
    jq -r '.src.smt_prelude' < config.json | xargs -I {} cp {} "$KLAB_REPORT_PROJECT_DIR"
  fi;
fi;

report () {
  set -e
  if [ ! -z "$KLAB_REPORT_NAME_DIR" ]; then
    exec 3>"$KLAB_REPORT_NAME_DIR"/report.json.lock
    flock -x 3 || exit 0
  fi;
  klab report
  if [ -n "$KLAB_REPORT_PROJECT_DIR" ]; then
    cp "$KLAB_OUT/report/index.html" "$KLAB_REPORT_PROJECT_DIR"
    concat=$(jq -s '.[0] * .[1]' "$KLAB_REPORT_DIR/$PNAME/report.json" "$KLAB_OUT/report/report.json")
    echo "$concat" > "$KLAB_REPORT_DIR/$PNAME/report.json"
    echo "Report exported to $KLAB_REPORT_PROJECT_DIR"
  fi;
  if [ ! -z "$KLAB_REPORT_NAME_DIR" ]; then
    exec 3>&-
  fi;
}
export -f report

# perform a single proof and exit
do_proof () {
  set -e

  name=$1
  hash=$(klab hash "$name")

  if [[ $name =~ .*_pass$ ]] || [[ $name =~ .*_pass_oog$ ]] ; then
    # do not dump _pass.k or pass_oog.k
    PROVE_DUMP=""
  else
    PROVE_DUMP="--dump"
  fi;

  _post_timeout () {
    echo "[do_proof] Timeout cleanup..."
    local hash=$1
    if [ -n "$hash" ]; then
      touch "$KLAB_OUT/timeout/$hash";
      klab get-lemmas "$hash"
      klab zip "$hash" > /dev/null
      echo "[do_proof] Zipped timed-out proof log for $hash."
      if [ -n "$KLAB_REPORT_NAME_DIR" ]; then
        cp "$KLAB_OUT/log/${hash}.zip" "$KLAB_REPORT_NAME_DIR"
      fi;
      echo "[do_proof] Saved time-out proof log for $hash."
    fi;
    echo "[DEBUG] finished timeout cleanup"
  }
  try_kill() {
    if [ -n "$1" ]; then
      echo "[do_proof] Sending SIGTERM to $1"
      pkill -x "$1" && echo "[do_proof] killed $1" || echo "[do_proof] unable to kill $1"
    fi;
  }
  _sig_term () {
    echo "[do_proof] Trapped SIGTERM."
    try_kill "$proof_child"
    _post_timeout "$hash"
  }
  trap _sig_term TERM
  _sig_int () {
    echo "[do_proof] Trapped SIGINT."
    try_kill "$proof_child"
    exit 1
  }
  trap _sig_int INT

  TIMER="/usr/bin/env time --quiet -o $KLAB_OUT/meta/time/$hash"

  # report start
  report
  touch "$RUNNING_DIR/$hash"

  set +e

  $TIMER klab prove $PROVE_DUMP --logs "$hash" & proof_child=$!
  wait "$proof_child"
  result=$?
  unset proof_child

  if [ $result -ne "0" ] && [ -z $PROVE_DUMP ]; then
    $TIMER klab prove --dump --logs "$hash" & proof_child=$!
    wait "$proof_child"
    result=$?
    unset proof_child
  fi;
  set -e

  # report finish
  rm "$RUNNING_DIR/$hash"
  report

  if [[ $name =~ .*_pass_rough$ ]] && [ $result -eq "0" ]; then
    # gas analysis from the rough pass
    klab get-gas "$hash"
    klab solve-gas "$hash"
  fi;

  if [ -n "$KLAB_REPORT_PROJECT_DIR" ] && [ -n "$PROVE_DUMP" ] && [ $result -ne "0" ]; then
    klab zip "$hash" > /dev/null
    cp "$KLAB_OUT/log/${hash}.zip" "$KLAB_REPORT_NAME_DIR"
    cp "$KLAB_OUT/log/${hash}.log" "$KLAB_REPORT_NAME_DIR"
    cp "$KLAB_OUT/log/${hash}.err.log" "$KLAB_REPORT_NAME_DIR"
    if [[ $name =~ .*_pass_rough$ ]]; then
      cp "$GAS_DIR/${hash}.kast" "$KLAB_REPORT_NAME_DIR"
      cp "$GAS_DIR/${hash}.raw.kast.json" "$KLAB_REPORT_NAME_DIR"
    fi;
  fi;

  if [ -n "$PROVE_DUMP" ]; then
    klab get-lemmas "$hash"
  fi

  # cleanup dumped data
  rm -fdr "$KLAB_OUT/data/${hash}_blobs"
  rm -fdr "$KLAB_OUT/data/${hash}.log"
  exit $result
}
export -f do_proof

function clean_running_dir {
  echo "Trapped EXIT, cleaning $RUNNING_DIR."
  rm -fdr "$KLAB_OUT/data" || true
  rm -fdr "$RUNNING_DIR" || true
  report
}
trap clean_running_dir EXIT


make_batch () {
  if [ -n "$KLAB_REPORT_PROJECT_DIR" ]; then
    cp -n "$KLAB_OUT"/specs/*.k "$KLAB_REPORT_NAME_DIR"
  fi;
  TIMEOUT=8400
  export TIMEOUT
  # timeout timeout after 10 minutes
  # (enough time to zip and bookkeeping)
  TIMEOUTTIMEOUT=600000
  export TIMEOUTTIMEOUT
  parallel -u --timeout $TIMEOUT --termseq TERM,$TIMEOUTTIMEOUT,KILL,25 -P "$THREADS" do_proof {} < "$OBLIGATIONS"
  result=$?
  echo $result
  if [ $result -ge 255 ]; then
    echo "Parallel finished with exceptional code:" "$result"
    exit $result
  else
    klab build;
    return $result
  fi;
}

echo "Doing initial spec build, this may take a while..."
mkdir -p "$GAS_DIR"
mkdir -p "$BEHAVIOUR_DIR"
mkdir -p "$RUNNING_DIR"
mkdir -p "$KLAB_OUT/meta/time"
mkdir -p "$KLAB_OUT/timeout"
rm -fdr "$KLAB_OUT/meta/name"
rm -fdr "$KLAB_OUT/specs"
klab build
if [ ! -z "$KLAB_REPORT_NAME_DIR" ]; then
  rm -f "$KLAB_REPORT_NAME_DIR/latest"
  ln -s "$KLAB_REPORT_PROJECT_DIR" "$KLAB_REPORT_NAME_DIR/latest"
fi
if [ -n "$KLAB_REPORT_PROJECT_DIR" ] && [ -f "$KLAB_OUT/bin_runtime.k" ]; then
  cp "$KLAB_OUT/bin_runtime.k" "$KLAB_REPORT_PROJECT_DIR"
fi
count=1
failures=0
while [ -s "$OBLIGATIONS" ]; do
  if [ $count -gt "$BATCH_LIMIT" ]; then
    echo "${red} Exceeded batch limit, terminating!"
    exit 1
  fi;
  echo "${bold}STARTING${reset} proof batch $count."
  set +e
  make_batch
  result=$?
  set -e
  # > 100 means SIGINT, etc.
  if [ $result -gt 100 ]; then exit 1; fi
  # parallel exit code is number of failures
  failures+=$result
  count=$((count+1))
done;
echo "${bold}COMPLETE${reset}: no outstanding proof obligations."
printf "Finished with %d failed proofs." $failures
if [ $failures -ge 1 ]; then
  exit 1
else
  exit 0
fi;
