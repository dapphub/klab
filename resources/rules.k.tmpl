// VERIFICATION.k

    rule #rangeUInt    (   1 ,      X ) => #range ( 0               <= X <= 1               ) [macro]

    rule bool2Word(notBool(A ==K 0)) => A
         requires #rangeUInt(1, A)

    //Blasphemy
    rule notBool(notBool(A)) => A

    rule ( WS1 ++ WS2 ) ++ WS3 => WS1 ++ ( WS2 ++ WS3 )


    // Same rules exist in KEVM, but are marked [concrete]. Allowing them for symbolic arguments here.

    rule #lookup( (KEY |-> VAL) M, KEY ) => VAL
    rule #lookup(               M, KEY ) => 0 requires notBool KEY in_keys(M)

    rule #range(WM, START, WIDTH) => #range(WM, START +Int WIDTH -Int 1, WIDTH, .WordStack)

    rule WM[ N := W : WS     ] => (WM[N <- W])[N +Int 1 := WS]

//Operator direction normalization rules. Required to reduce the number of forms of inequalities that can be matched by general lemmas. We chose to keep <Int and <=Int because those operators are used in all range lemmas and in #range macros. Operators >Int and >=Int are still allowed anywhere except rules LHS. In all other places they will be matched and rewritten by rules below.
rule notBool (X <Int Y)  => Y <=Int X
rule notBool (X <=Int Y) => Y <Int X
rule notBool (X >Int Y)  => X <=Int Y
rule notBool (X >=Int Y) => X <Int Y



    rule 0 <=Int nthbyteof(V, I, N)          => true
    rule         nthbyteof(V, I, N) <Int 256 => true


rule ACCTCODE in SetItem( 1 )
                 SetItem ( 2 )
                 SetItem ( 3 )
                 SetItem ( 4 )
                 SetItem ( 5 )
                 SetItem ( 6 )
                 SetItem ( 7 )
                 SetItem ( 8 )
                 => false
     requires 9 <=Int ACCTCODE

    syntax IntList ::= bytesToWords ( WordStack )       [function]

 // --------------------------------------------------------------
    rule bytesToWords ( WS )
         => #asWord(#take(#sizeWordStack(WS) modInt 32, WS)) byteStack2IntList(#drop(#sizeWordStack(WS) modInt 32, WS))
         requires 0 <Int #sizeWordStack(WS) modInt 32

    rule bytesToWords ( WS ) => byteStack2IntList(WS)
         requires #sizeWordStack(WS) modInt 32 ==Int 0

// for terms came from bytecode not via #hashedLocation
    rule keccak(WS) => keccakIntList(bytesToWords(WS))
      requires ( notBool #isConcrete(WS) )

    rule 0 <=Int keccakIntList(N)     => true
    rule keccaktIntList(N) <Int pow256 => true
      
    // for Solidity (WORDSTACK)
    rule #asWord(WS) /Int D => #asWord(#take(#sizeWordStack(WS) -Int log256Int(D), WS))
      requires D modInt 256 ==Int 0 andBool D >=Int 0
       andBool #sizeWordStack(WS) >=Int log256Int(D)
       andBool #sizeWordStack(WS) <=Int 32

    // for Solidity >= 0.5.6 (WORDSTACK)
    rule #asWord(WS) >>Int D => #asWord(#take(#sizeWordStack(WS) -Int (D /Int 8), WS))
     requires D modInt 8 ==Int 0 andBool D >=Int 0
       andBool #sizeWordStack(WS) >=Int (D /Int 8)
       andBool #sizeWordStack(WS) <=Int 32
    rule #sizeWordStack(#take(N, _)) => N
    rule #sizeWordStack(#take(N, _), M) => N +Int M

    // for Solidity (BYTEARRAY)
    rule #asWord(WS) /Int D => #asWord(WS [0 .. #sizeByteArray(WS) -Int log256Int(D)])
      requires D modInt 256 ==Int 0 andBool D >=Int 0
       andBool #sizeByteArray(WS) >=Int log256Int(D)
       andBool #sizeByteArray(WS) <=Int 32

    // for Solidity >= 0.5.6 (BYTEARRAY)
    rule #asWord(BS) >>Int D => #asWord(BS [0 .. #sizeByteArray(BS) -Int (D /Int 8)])
     requires D modInt 8 ==Int 0 andBool D >=Int 0
       andBool #sizeByteArray(BS) >=Int (D /Int 8)
       andBool #sizeByteArray(BS) <=Int 32

    rule #sizeByteArray(BS [0 .. N]) => N

    rule BS [0 .. N] [0 .. M] => BS [0 .. M]
    requires M <=Int N

    rule 0 +Int N => N
    rule N +Int 0 => N

    rule N -Int 0 => N

    rule 1 *Int N => N
    rule N *Int 1 => N
    rule 0 *Int _ => 0
    rule _ *Int 0 => 0

    rule N /Int 1 => N
    rule N *Int A /Int A => N

    rule 0 |Int N => N
    rule N |Int 0 => N
    rule N |Int N => N

    rule 0 &Int N => 0
    rule N &Int 0 => 0
    rule N &Int N => N

    rule N <<Int 0 => N
    rule N >>Int 0 => N

    rule (I1 +Int I2) +Int I3 => I1 +Int (I2 +Int I3) when #isConcrete(I2) andBool #isConcrete(I3)
    rule (I1 +Int I2) -Int I3 => I1 +Int (I2 -Int I3) when #isConcrete(I2) andBool #isConcrete(I3)
    rule (I1 -Int I2) +Int I3 => I1 -Int (I2 -Int I3) when #isConcrete(I2) andBool #isConcrete(I3)
    rule (I1 -Int I2) -Int I3 => I1 -Int (I2 +Int I3) when #isConcrete(I2) andBool #isConcrete(I3)

    rule I1 &Int (I2 &Int I3) => (I1 &Int I2) &Int I3 when #isConcrete(I1) andBool #isConcrete(I2)

    // 0xffff...f &Int N = N
    rule MASK &Int N => N  requires MASK ==Int (2 ^Int (log2Int(MASK) +Int 1)) -Int 1 // MASK = 0xffff...f
                            andBool 0 <=Int N andBool N <=Int MASK

    // 0xffff...f &Int N = N
    rule N &Int MASK => N  requires MASK ==Int (2 ^Int (log2Int(MASK) +Int 1)) -Int 1 // MASK = 0xffff...f
                            andBool 0 <=Int N andBool N <=Int MASK


    /// GAS Simplification
    rule (#if C #then B1 #else B2 #fi) >Int A => true
      requires B1 >Int A andBool B2 >Int A

    rule (#if C #then B1 #else B2 #fi) >=Int A => true
      requires B1 >=Int A andBool B2 >=Int A

    rule #if C #then (#if C #then B1 #else B2 #fi) -Int D #else (#if C #then B3 #else B4 #fi) -Int E #fi =>
         #if C #then B1 -Int D #else B4 -Int E #fi

    // propagate stuff out of #ifs

    rule #if C #then X #else Y #fi => Y +Int #if C #then X -Int Y #else 0 #fi
      requires #isConcrete(X)
      andBool  #isConcrete(Y)
      andBool  X >Int Y
      andBool  Y =/=Int 0

    rule #if C #then X #else Y #fi => X +Int #if C #then 0 #else Y -Int X #fi
      requires #isConcrete(X)
      andBool  #isConcrete(Y)
      andBool  Y >Int X
      andBool  X =/=Int 0

    rule #if C #then X +Int A #else X +Int B #fi => X +Int (#if C #then A #else B #fi)

    rule #if C #then (A +Int X) #else (B +Int X) #fi => ( #if C #then A #else B #fi ) +Int X

    rule #if C #then G -Int X #else G -Int Y #fi => G -Int (#if C #then X #else Y #fi)

    rule #if C #then X -Int G #else Y -Int G #fi => (#if C #then X #else Y #fi) -Int G

    rule #if C #then ((P -Int X) -Int A) #else ((Q -Int X) -Int B) #fi => (#if C #then (P -Int A) #else (Q -Int B) #fi) -Int X

    // NEW GAS LEMMAS
    // join together concrete numbers
    rule (A -Int  B) -Int C  =>  A -Int (B +Int C)
    rule (A -Int  B) +Int C  =>  A -Int (B -Int C)
    rule (A +Int B) -Int C  => A +Int (B -Int C)
    rule (A +Int B) +Int  C => A +Int (B +Int C)

    // deal with 0
    rule  A +Int (0 -Int  C) => A -Int C
      requires (notBool #isConcrete(C))
    rule  A -Int (0 -Int  C) => A +Int C
      requires (notBool #isConcrete(C))


    // deal with negative concrete number
    rule A -Int B => A +Int (0 -Int B)
      requires #isConcrete(B)
      andBool B <Int 0

    rule A +Int B => A -Int (0 -Int B)
      requires #isConcrete(B)
      andBool B <Int 0

    // SORT

    //    DIV
    rule  A -Int ( (B /Int 64)  +Int C) => (0 -Int ( (B /Int 64) -Int (A -Int C)))
      requires (notBool #isVariable(A))
      andBool (notBool #isConcrete(A))
      andBool (A =/=K (D /Int 64))
    rule  A -Int ( (B /Int 64)  -Int C) => (0 -Int ( (B /Int 64) -Int (A +Int C)))
      requires (notBool #isVariable(A))
      andBool (notBool #isConcrete(A))
      andBool (A =/=K (D /Int 64))
    rule  A +Int ( (B /Int 64) +Int  C) => (B /Int 64) +Int (A +Int  C)
      requires (notBool #isVariable(A))
      andBool (notBool #isConcrete(A))
      andBool (A =/=K (D /Int 64))
    rule  A +Int ( (B /Int 64) -Int  C) => (B /Int 64) +Int (A -Int  C)
      requires (notBool #isVariable(A))
      andBool (notBool #isConcrete(A))
      andBool (A =/=K (D /Int 64))

    //    VAR
    rule  A -Int (B  +Int C) => (0 -Int (B -Int (A -Int C)))
      requires #isVariable(B)
      andBool (notBool #isVariable(A))
      andBool (A =/=K 0)
    rule  A -Int (B  -Int C) => (0 -Int (B -Int (A +Int C)))
      requires #isVariable(B)
      andBool (notBool #isVariable(A))
      andBool (A =/=K 0)
    rule  A +Int (B +Int  C) => B +Int (A +Int  C)
      requires #isVariable(B)
      andBool (notBool #isVariable(A))
      andBool (A =/=K 0)
    rule  A +Int (B -Int  C) => B +Int (A -Int  C)
      requires #isVariable(B)
      andBool (notBool #isVariable(A))
      andBool (A =/=K 0)

    //    CONCRETE
    rule  A -Int (B  +Int C) => (0 -Int (B -Int (A -Int C)))
      requires #isConcrete(A)
      andBool A =/=Int 0
      andBool (notBool #isConcrete(B))
    rule  A -Int (B  -Int C) => (0 -Int (B -Int (A +Int C)))
      requires #isConcrete(A)
      andBool A =/=Int 0
      andBool (notBool #isConcrete(B))
    rule  A +Int (B +Int  C) => B +Int (A +Int  C)
      requires #isConcrete(A)
      andBool (notBool #isConcrete(B))
    rule  A +Int (B -Int  C) => B +Int (A -Int  C)
      requires #isConcrete(A)
      andBool (notBool #isConcrete(B))

    // SOLVE
    //    duplicates
    rule A -Int (A +Int B) => 0 -Int B
    rule A -Int (A -Int B) => B
    rule A -Int (B +Int (A +Int C)) => 0 -Int (B +Int C)
    rule A -Int (B +Int (A -Int C)) => 0 -Int (B -Int C)

    //    concrete
    rule  A -Int (B  -Int C) => (A -Int  B) +Int C
      requires #isConcrete(A)
      andBool  #isConcrete(B)
    rule  A -Int (B  +Int C) => (A -Int  B) -Int C
      requires #isConcrete(A)
      andBool  #isConcrete(B)
    rule  A +Int (B -Int  C) => (A +Int  B) -Int C
      requires #isConcrete(A)
      andBool  #isConcrete(B)
    rule  A +Int (B +Int  C) => (A +Int  B) +Int C
      requires #isConcrete(A)
      andBool  #isConcrete(B)



    /// ---


    rule A -Int A => 0

    rule bool2Word(A) |Int bool2Word(B) => bool2Word(A  orBool B)
    rule bool2Word(A) &Int bool2Word(B) => bool2Word(A andBool B)

    rule bool2Word(A)  ==K 0 => notBool(A)
    rule bool2Word(A)  ==K 1 => A

    rule 1 |Int bool2Word(X) => 1
    rule  bool2Word(X) |Int 1 => 1
    rule 1 &Int bool2Word(X) => bool2Word(X)
    rule bool2Word(X) &Int 1 => bool2Word(X)

    rule chop(bool2Word(B)) => bool2Word(B)





    rule 0 <=Int chop(V)             => true
    rule         chop(V) <Int pow256 => true

    rule 0 <=Int keccak(V)             => true
    rule         keccak(V) <Int pow256 => true

    rule 0 <=Int X &Int Y             => true requires 0 <=Int X andBool X <Int pow256 andBool 0 <=Int Y andBool Y <Int pow256
    rule         X &Int Y <Int pow256 => true requires 0 <=Int X andBool X <Int pow256 andBool 0 <=Int Y andBool Y <Int pow256





    rule chop(I) => I requires 0 <=Int I andBool I <Int pow256




    rule #sizeWordStack ( _ , _ ) >=Int 0 => true [smt-lemma]
    rule #sizeWordStack ( WS , N:Int )
      => #sizeWordStack ( WS , 0 ) +Int N
      requires N =/=K 0
      [lemma]

rule chop(#unsigned(W)) => #unsigned(W)
  requires #rangeSInt(256, W)

rule #signed(#unsigned(W)) => W
  requires #rangeSInt(256, W)

rule #unsigned(#signed(W)) => W
  requires #rangeUInt(256, W)

rule W0 s<Word W1 => #signed(W0) <Word #signed(W1)

rule   #signed(X) ==K   #signed(Y) => X ==K Y requires #rangeUInt(256,X) orBool #rangeUInt(256,Y)
rule #unsigned(X) ==K #unsigned(Y) => X ==K Y requires #rangeSInt(256,X) orBool #rangeSInt(256,Y)


rule A modInt pow160 => A
  requires #rangeAddress(A)

syntax Bool ::= #notPrecompileAddress ( Int ) [function]
// ---------------------------------------
rule #notPrecompileAddress ( X ) => 0 <Int X andBool 9 <=Int X andBool #rangeAddress(X)

// ABSTRACT SEMANTICS.k

  rule <k> LT W0 W1 => bool2Word(W0  <Int W1) ~> #push ... </k> [trusted]
  rule <k> GT W0 W1 => bool2Word(W0  >Int W1) ~> #push ... </k> [trusted]
  rule <k> EQ W0 W1 => bool2Word(W0 ==Int W1) ~> #push ... </k> [trusted]
  rule <k> ISZERO W => bool2Word(W  ==Int 0 ) ~> #push ... </k> [trusted]


//RULES MUST USE ==K and not ==Int
//Warning: assumes injective hashing
rule keccakIntList(A B .IntList) ==K keccakIntList(C D .IntList) => A ==Int C andBool B ==Int D

rule keccakIntList(A B C .IntList) ==K keccakIntList(D E F .IntList) => A ==Int D andBool B ==Int E andBool C ==Int F


rule keccakIntList(C) ==K A => false
     requires 0 <=Int A andBool A <=Int 20

rule keccakIntList(C) +Int B ==K A => false
     requires 0 <=Int A andBool A <=Int 20
     andBool 0 <=Int B andBool B <=Int 20

rule A ==K keccakIntList(C) +Int B => false
     requires 0 <=Int A andBool A <=Int 20
     andBool 0 <=Int B andBool B <=Int 20

rule keccakIntList(C) +Int B ==K keccakIntList(A) => false
     requires 0 <=Int B andBool B <=Int 20

rule keccakIntList(A) +Int B ==K keccakIntList(A) +Int C => false
     requires B =/=Int C

rule keccakIntList(A) +Int B ==K keccakIntList(C) +Int D => false
     requires B =/=K C


rule keccakIntList(A) ==K keccakIntList(C) +Int B => false
     requires 0 <=Int B andBool B <=Int 20


rule A ==K keccakIntList(C) => false
     requires 0 <=Int A andBool A <=Int 20

rule Cgascap(SCHED, GCAP, GAVAIL, GEXTRA) => #if GAVAIL <Int GEXTRA orBool Gstaticcalldepth << SCHED >> #then GCAP #else minInt(#allBut64th(GAVAIL -Int GEXTRA), GCAP) #fi

rule Csstore(SCHED, NEW, CURR, ORIG)
  => #if CURR ==Int NEW orBool ORIG =/=Int CURR #then Gsload < SCHED > #else #if ORIG ==Int 0 #then Gsstoreset < SCHED > #else Gsstorereset < SCHED > #fi #fi
  requires Ghasdirtysstore << SCHED >>

rule Csstore(SCHED, NEW, CURR, ORIG)
  => #if CURR ==Int 0 andBool NEW =/=Int 0 #then Gsstoreset < SCHED > #else Gsstorereset < SCHED > #fi
  requires notBool Ghasdirtysstore << SCHED >>

rule Rsstore(SCHED, NEW, CURR, ORIG) => #if CURR =/=Int 0 andBool NEW ==Int 0 #then Rsstoreclear < SCHED > #else 0 #fi
      requires notBool Ghasdirtysstore << SCHED >>

rule Cextra(SCHED, ISEMPTY, VALUE) => Gcall < SCHED > +Int Cnew(SCHED, ISEMPTY, VALUE) +Int Cxfer(SCHED, VALUE)

rule Cmem(SCHED, N) => (N *Int Gmemory < SCHED >) +Int ((N *Int N) /Int Gquadcoeff < SCHED >)

//Symbolic wrapper over the argument of #ecrec, no implementation.
//                         hash v  r   s
syntax Int ::= #symEcrec ( Int , Int , Int , Int ) [function]

rule <k> ECREC => #end EVMC_SUCCESS ... </k>
       <callData> DATA </callData>
       <output> _ => #ecrec(#symEcrec(#asWord(#take(32, DATA)), #asWord(#take(32, #drop(32, DATA))), #asWord(#take(32, #drop(64, DATA))), #asWord(#take(32, #drop(96, DATA))))) </output>
    requires notBool #isConcrete(DATA) andBool #sizeWordStack(DATA) ==Int 128
[trusted]

// -- from evm-data-map-symbolic.k --

rule #memoryUsageUpdate(MU, START, WIDTH) => maxInt(MU, (START +Int WIDTH) up/Int 32) requires WIDTH  >Int 0

rule ( WS1 ++ WS2 ) ++ WS3 => WS1 ++ ( WS2 ++ WS3 )

syntax ByteArray ::= #bufSeg ( ByteArray , Int , Int ) [function, smtlib(bufSeg)] // BUFFER, START, WIDTH
syntax Int       ::= #bufElm ( ByteArray , Int )       [function] // BUFFER, INDEX

syntax Bool ::= #isBuf ( ByteArray ) [function]
rule #isBuf(#buf(_,_)) => true
rule #isBuf(#bufSeg(_,_,_)) => true

rule #asWord(#buf(SIZE, DATA)) => DATA requires SIZE <=Int 32

rule #buf(SIZE, _)        => .WordStack requires SIZE  ==Int 0
rule #bufSeg(_, _, WIDTH) => .WordStack requires WIDTH ==Int 0

rule #bufSeg(WS, START, WIDTH) => WS requires START ==Int 0 andBool WIDTH ==Int #sizeWordStack(WS)

rule #bufSeg(#bufSeg(BUF, START0, WIDTH0), START, WIDTH)
    => #bufSeg(BUF, START0 +Int START, WIDTH)
    requires 0 <=Int START andBool START +Int WIDTH <=Int WIDTH0

// Auxiliary function to make rules compatible with simplification `rule WS ++ .WordStack => WS`
syntax ByteArray ::= #takeAux ( Int , ByteArray , ByteArray ) [function]
// ------------------------------------------------------------------------
rule #take(N, BUF      ) => #takeAux(N, BUF, .WordStack)               requires #isBuf(BUF)
rule #take(N, BUF ++ WS) => #takeAux(N, BUF, WS)                       requires #isBuf(BUF)
rule #takeAux(N, BUF, WS) => #bufSeg(BUF, 0, N)                        requires 0 <=Int N andBool N <=Int #sizeBuffer(BUF)
rule #takeAux(N, BUF, WS) => BUF ++ #take(N -Int #sizeBuffer(BUF), WS) requires N >Int #sizeBuffer(BUF)

syntax ByteArray ::= #dropAux ( Int , ByteArray , ByteArray ) [function]
// ------------------------------------------------------------------------
rule #drop(N, BUF      ) => #dropAux(N, BUF, .WordStack)                    requires #isBuf(BUF)
rule #drop(N, BUF ++ WS) => #dropAux(N, BUF, WS)                            requires #isBuf(BUF)
rule #dropAux(N, BUF, WS) => #bufSeg(BUF, N, #sizeBuffer(BUF) -Int N) ++ WS requires 0 <=Int N andBool N <=Int #sizeBuffer(BUF)
rule #dropAux(N, BUF, WS) => #drop(N -Int #sizeBuffer(BUF), WS)             requires N >=Int #sizeBuffer(BUF)

syntax Int ::= #getElmAux ( ByteArray , ByteArray , Int ) [function]
// --------------------------------------------------------------------
rule (BUF      ) [ N ] => #getElmAux(BUF, .WordStack, N)      requires #isBuf(BUF)
rule (BUF ++ WS) [ N ] => #getElmAux(BUF, WS, N)              requires #isBuf(BUF)
rule #getElmAux(BUF, WS, N) => #bufElm(BUF, N)                requires 0 <=Int N andBool N <Int #sizeBuffer(BUF)
rule #getElmAux(BUF, WS, N) => WS [ N -Int #sizeBuffer(BUF) ] requires N >=Int #sizeBuffer(BUF)


rule #sizeWordStack ( BUF ++ WS, SIZE ) => #sizeWordStack(WS, SIZE +Int #sizeBuffer(BUF)) requires #isBuf(BUF)
rule #sizeWordStack ( BUF      , SIZE ) =>                    SIZE +Int #sizeBuffer(BUF)  requires #isBuf(BUF)

syntax Int ::= #sizeBuffer ( ByteArray ) [function]
// ---------------------------------------------------
rule #sizeBuffer ( #buf(N,_) )      => N
rule #sizeBuffer ( #bufSeg(_,_,N) ) => N


// ########################
// Symbolic Word Map
// ########################

syntax Map ::= store  ( Map , Int , Int ) [function, smtlib(storeInt) ]
syntax Int ::= select ( Map , Int )       [function, smtlib(selectInt)]
// -----------------------------------------------------------------------
rule select(store(M, K0, V), K) => V            requires K0  ==Int K
rule select(store(M, K0, V), K) => select(M, K) requires K0 =/=Int K

syntax Map       ::= storeRange  ( Map , Int , Int , ByteArray ) [function, smtlib(storeRange) ]
syntax ByteArray ::= selectRange ( Map , Int , Int )             [function, smtlib(selectRange)]
// ------------------------------------------------------------------------------------------------
rule select(storeRange(M, START, WIDTH, WS), K) => WS[K -Int START] requires          START <=Int K andBool K <Int START +Int WIDTH
rule select(storeRange(M, START, WIDTH, WS), K) => select(M, K)     requires notBool (START <=Int K andBool K <Int START +Int WIDTH)

rule selectRange(store(M, K0, V), START, WIDTH) => selectRange(M, START, WIDTH) requires ( K0 <Int START orBool START +Int WIDTH <=Int K0 ) // no overlap

// included: [START0..[START..END]..END0]
rule selectRange(storeRange(M, START0, WIDTH0, WS), START, WIDTH) => WS [ START -Int START0 .. WIDTH ]
    requires START0 <=Int START andBool START +Int WIDTH <=Int START0 +Int WIDTH0

// no overlap: [START..END]..[START0..END0]  or  [START0..END0]..[START..END]
rule selectRange(storeRange(M, START0, WIDTH0, WS), START, WIDTH) => selectRange(M, START, WIDTH)
    requires ( (START +Int WIDTH) <=Int START0 orBool (START0 +Int WIDTH0) <=Int START )

// left  margin: [START..(START0..END]..END0)  or  [START..(START0..END0)..END]
rule selectRange(storeRange(M, START0, WIDTH0, WS), START, WIDTH) => selectRange(M, START, START0 -Int START)
                                                                    ++ selectRange(storeRange(M, START0, WIDTH0, WS), START0, (START +Int WIDTH) -Int START0)
    requires START <Int START0 andBool START0 <Int START +Int WIDTH
    andBool WIDTH0 >=Int 1 // to avoid unnecessary split

// right margin: (START0..[START..END0)..END]  or  [START..(START0..END0)..END]
rule selectRange(storeRange(M, START0, WIDTH0, WS), START, WIDTH) => selectRange(storeRange(M, START0, WIDTH0, WS), START, (START0 +Int WIDTH0) -Int START)
                                                                    ++ selectRange(M, START0 +Int WIDTH0, (START +Int WIDTH) -Int (START0 +Int WIDTH0))
    requires START <Int START0 +Int WIDTH0 andBool START0 +Int WIDTH0 <Int START +Int WIDTH
    andBool WIDTH0 >=Int 1 // to avoid unnecessary split

rule storeRange(M, _, WIDTH, _) => M requires WIDTH ==Int 0

rule selectRange(M, _, WIDTH) => .WordStack requires WIDTH ==Int 0

// lifting

rule #lookup(M, K:Int)         => select(M, K)   requires notBool (#isConcrete(M) andBool #isConcrete(K))
rule M:Map [ K:Int <- V:Int ]  => store(M, K, V) requires notBool (#isConcrete(M) andBool #isConcrete(K) andBool #isConcrete(V))

rule #range(M, START, WIDTH) => selectRange(M, START, WIDTH)                 requires notBool (#isConcrete(M) andBool #isConcrete(START) andBool #isConcrete(WIDTH))
rule M [ START := WS ]       => storeRange(M, START, #sizeWordStack(WS), WS) requires notBool (#isConcrete(M) andBool #isConcrete(START) andBool #isConcrete(WS))

// once it gets down to the concrete map, return to the corresponding function
// shouldn't have the infinite rule application
rule select(M, K)                 => #lookup(M, K)           [concrete]
rule selectRange(M, START, WIDTH) => #range(M, START, WIDTH) [concrete]

// we want symbolic arguments to remain in #buf form.
rule #padToWidth(32, #asByteStack(V)) => #buf(32, V)
      requires 0 <=Int V andBool V <Int pow256
